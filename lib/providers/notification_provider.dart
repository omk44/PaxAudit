import 'package:flutter/material.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import '../models/notification.dart';

class NotificationProvider with ChangeNotifier {
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;

  List<NotificationModel> _notifications = [];
  bool _isLoading = false;
  String? _error;
  String? _currentCAEmail;

  // Getters
  List<NotificationModel> get notifications => _notifications;
  bool get isLoading => _isLoading;
  String? get error => _error;
  int get unreadCount => _notifications.where((n) => !n.isRead).length;
  bool get hasUnreadNotifications => unreadCount > 0;

  // Load notifications for a specific CA
  Future<void> loadNotificationsForCA(String caEmail) async {
    try {
      _isLoading = true;
      _error = null;
      _currentCAEmail = caEmail;
      notifyListeners();

      final querySnapshot = await _firestore
          .collection('notifications')
          .where('caEmail', isEqualTo: caEmail)
          .orderBy('timestamp', descending: true)
          .limit(50) // Limit to last 50 notifications
          .get();

      _notifications = querySnapshot.docs
          .map((doc) => NotificationModel.fromQueryDocument(doc))
          .toList();

      _isLoading = false;
      notifyListeners();
    } catch (e) {
      _error = 'Failed to load notifications: ${e.toString()}';
      _isLoading = false;
      notifyListeners();
    }
  }

  // Create a new notification
  Future<bool> createNotification({
    required String title,
    required String message,
    required String type,
    required String action,
    required String companyId,
    required String caEmail,
    required String performedBy,
    Map<String, dynamic>? metadata,
  }) async {
    try {
      final notification = NotificationModel(
        id: '', // Will be generated by Firestore
        title: title,
        message: message,
        type: type,
        action: action,
        companyId: companyId,
        caEmail: caEmail,
        performedBy: performedBy,
        timestamp: DateTime.now(),
        metadata: metadata,
      );

      await _firestore
          .collection('notifications')
          .add(notification.toFirestore());

      // If this notification is for the current CA, add it to local list
      if (_currentCAEmail == caEmail) {
        final newNotification = notification.copyWith(
          id: DateTime.now().millisecondsSinceEpoch.toString(), // Temporary ID
        );
        _notifications.insert(0, newNotification);
        notifyListeners();
      }

      return true;
    } catch (e) {
      print('Error creating notification: $e');
      return false;
    }
  }

  // Mark notification as read
  Future<bool> markAsRead(String notificationId) async {
    try {
      await _firestore.collection('notifications').doc(notificationId).update({
        'isRead': true,
      });

      // Update local list
      final index = _notifications.indexWhere((n) => n.id == notificationId);
      if (index != -1) {
        _notifications[index] = _notifications[index].copyWith(isRead: true);
        notifyListeners();
      }

      return true;
    } catch (e) {
      _error = 'Failed to mark notification as read: ${e.toString()}';
      notifyListeners();
      return false;
    }
  }

  // Mark all notifications as read
  Future<bool> markAllAsRead() async {
    try {
      final unreadNotifications = _notifications
          .where((n) => !n.isRead)
          .toList();

      if (unreadNotifications.isEmpty) return true;

      final batch = _firestore.batch();
      for (final notification in unreadNotifications) {
        final docRef = _firestore
            .collection('notifications')
            .doc(notification.id);
        batch.update(docRef, {'isRead': true});
      }
      await batch.commit();

      // Update local list
      for (int i = 0; i < _notifications.length; i++) {
        if (!_notifications[i].isRead) {
          _notifications[i] = _notifications[i].copyWith(isRead: true);
        }
      }
      notifyListeners();

      return true;
    } catch (e) {
      _error = 'Failed to mark all notifications as read: ${e.toString()}';
      notifyListeners();
      return false;
    }
  }

  // Delete a notification
  Future<bool> deleteNotification(String notificationId) async {
    try {
      await _firestore.collection('notifications').doc(notificationId).delete();

      _notifications.removeWhere((n) => n.id == notificationId);
      notifyListeners();

      return true;
    } catch (e) {
      _error = 'Failed to delete notification: ${e.toString()}';
      notifyListeners();
      return false;
    }
  }

  // Clear all notifications
  Future<bool> clearAllNotifications() async {
    try {
      if (_currentCAEmail == null) return false;

      final querySnapshot = await _firestore
          .collection('notifications')
          .where('caEmail', isEqualTo: _currentCAEmail)
          .get();

      final batch = _firestore.batch();
      for (final doc in querySnapshot.docs) {
        batch.delete(doc.reference);
      }
      await batch.commit();

      _notifications.clear();
      notifyListeners();

      return true;
    } catch (e) {
      _error = 'Failed to clear notifications: ${e.toString()}';
      notifyListeners();
      return false;
    }
  }

  // Helper method to create notification for expense changes
  Future<bool> notifyExpenseChange({
    required String action, // 'created', 'updated', 'deleted'
    required String companyId,
    required String caEmail,
    required String performedBy,
    required String expenseDescription,
    required double amount,
    String? expenseId,
  }) async {
    String title;
    String message;

    switch (action) {
      case 'created':
        title = 'New Expense Added';
        message =
            'A new expense of ₹${amount.toStringAsFixed(2)} for "$expenseDescription" has been added.';
        break;
      case 'updated':
        title = 'Expense Updated';
        message =
            'Expense "$expenseDescription" (₹${amount.toStringAsFixed(2)}) has been updated.';
        break;
      case 'deleted':
        title = 'Expense Deleted';
        message =
            'Expense "$expenseDescription" (₹${amount.toStringAsFixed(2)}) has been deleted.';
        break;
      default:
        title = 'Expense Modified';
        message = 'Expense "$expenseDescription" has been modified.';
    }

    return await createNotification(
      title: title,
      message: message,
      type: 'expense',
      action: action,
      companyId: companyId,
      caEmail: caEmail,
      performedBy: performedBy,
      metadata: {
        'expenseId': expenseId,
        'amount': amount,
        'description': expenseDescription,
      },
    );
  }

  // Helper method to create notification for income changes
  Future<bool> notifyIncomeChange({
    required String action, // 'created', 'updated', 'deleted'
    required String companyId,
    required String caEmail,
    required String performedBy,
    required String incomeDescription,
    required double amount,
    String? incomeId,
  }) async {
    String title;
    String message;

    switch (action) {
      case 'created':
        title = 'New Income Added';
        message =
            'A new income of ₹${amount.toStringAsFixed(2)} for "$incomeDescription" has been added.';
        break;
      case 'updated':
        title = 'Income Updated';
        message =
            'Income "$incomeDescription" (₹${amount.toStringAsFixed(2)}) has been updated.';
        break;
      case 'deleted':
        title = 'Income Deleted';
        message =
            'Income "$incomeDescription" (₹${amount.toStringAsFixed(2)}) has been deleted.';
        break;
      default:
        title = 'Income Modified';
        message = 'Income "$incomeDescription" has been modified.';
    }

    return await createNotification(
      title: title,
      message: message,
      type: 'income',
      action: action,
      companyId: companyId,
      caEmail: caEmail,
      performedBy: performedBy,
      metadata: {
        'incomeId': incomeId,
        'amount': amount,
        'description': incomeDescription,
      },
    );
  }

  // Helper method to create notification for bank statement changes
  Future<bool> notifyBankStatementChange({
    required String action, // 'created', 'updated', 'deleted', 'commented'
    required String companyId,
    required String caEmail,
    required String performedBy,
    required String bankStatementTitle,
    String? bankStatementId,
    String? comments,
  }) async {
    String title;
    String message;

    switch (action) {
      case 'created':
        title = 'New Bank Statement Added';
        message = 'A new bank statement "$bankStatementTitle" has been added.';
        break;
      case 'updated':
        title = 'Bank Statement Updated';
        message = 'Bank statement "$bankStatementTitle" has been updated.';
        break;
      case 'deleted':
        title = 'Bank Statement Deleted';
        message = 'Bank statement "$bankStatementTitle" has been deleted.';
        break;
      case 'commented':
        title = 'Bank Statement Commented';
        message =
            'A comment has been added to bank statement "$bankStatementTitle".';
        break;
      default:
        title = 'Bank Statement Modified';
        message = 'Bank statement "$bankStatementTitle" has been modified.';
    }

    return await createNotification(
      title: title,
      message: message,
      type: 'bank_statement',
      action: action,
      companyId: companyId,
      caEmail: caEmail,
      performedBy: performedBy,
      metadata: {
        'bankStatementId': bankStatementId,
        'title': bankStatementTitle,
        'comments': comments,
      },
    );
  }

  // Helper method to get admin email for a company
  Future<String?> _getAdminEmailForCompany(String companyId) async {
    try {
      final companyDoc = await _firestore
          .collection('companies')
          .doc(companyId)
          .get();
      if (companyDoc.exists) {
        final data = companyDoc.data() as Map<String, dynamic>;
        return data['adminEmail'] as String?;
      }
      return null;
    } catch (e) {
      print('Error getting admin email: $e');
      return null;
    }
  }

  // Helper method to get CA emails for a company
  Future<List<String>> _getCAEmailsForCompany(String companyId) async {
    try {
      final companyDoc = await _firestore
          .collection('companies')
          .doc(companyId)
          .get();
      if (companyDoc.exists) {
        final data = companyDoc.data() as Map<String, dynamic>;
        final caEmails = data['caEmails'] as List<dynamic>?;
        return caEmails?.cast<String>() ?? [];
      }
      return [];
    } catch (e) {
      print('Error getting CA emails: $e');
      return [];
    }
  }

  // Helper method to send notifications to admin when CA makes changes
  Future<bool> notifyAdminOfCAChange({
    required String action, // 'created', 'updated', 'deleted'
    required String companyId,
    required String performedBy, // CA email
    required String itemDescription,
    required double amount,
    required String itemType, // 'expense' or 'income'
    String? itemId,
    String? adminEmail, // Pass admin email directly
  }) async {
    try {
      // Use provided admin email or try to get from company
      String? targetAdminEmail = adminEmail;
      if (targetAdminEmail == null) {
        targetAdminEmail = await _getAdminEmailForCompany(companyId);
      }

      if (targetAdminEmail == null) {
        print('No admin email found for company: $companyId');
        return false;
      }

      String title;
      String message;

      switch (action) {
        case 'created':
          title = 'CA Added New $itemType';
          message =
              'CA $performedBy added a new $itemType of ₹${amount.toStringAsFixed(2)} for "$itemDescription".';
          break;
        case 'updated':
          title = 'CA Updated $itemType';
          message =
              'CA $performedBy updated $itemType "$itemDescription" (₹${amount.toStringAsFixed(2)}).';
          break;
        case 'deleted':
          title = 'CA Deleted $itemType';
          message =
              'CA $performedBy deleted $itemType "$itemDescription" (₹${amount.toStringAsFixed(2)}).';
          break;
        default:
          title = 'CA Modified $itemType';
          message = 'CA $performedBy modified $itemType "$itemDescription".';
      }

      return await createNotification(
        title: title,
        message: message,
        type: 'ca_${itemType}',
        action: action,
        companyId: companyId,
        caEmail: targetAdminEmail, // Send to admin
        performedBy: performedBy,
        metadata: {
          'itemId': itemId,
          'amount': amount,
          'description': itemDescription,
          'itemType': itemType,
          'performedBy': performedBy,
        },
      );
    } catch (e) {
      print('Error sending admin notification: $e');
      return false;
    }
  }

  // Test method to create a sample notification
  Future<bool> createTestNotification(String email) async {
    return await createNotification(
      title: 'Test Notification',
      message: 'This is a test notification to verify the system is working.',
      type: 'test',
      action: 'created',
      companyId: 'test-company',
      caEmail: email,
      performedBy: 'System',
      metadata: {'test': true},
    );
  }

  // Static method to send notifications from anywhere
  static Future<void> sendNotificationToAdmin({
    required String action,
    required String companyId,
    required String performedBy,
    required String itemDescription,
    required double amount,
    required String itemType,
    String? itemId,
  }) async {
    try {
      final notificationProvider = NotificationProvider();
      await notificationProvider.notifyAdminOfCAChange(
        action: action,
        companyId: companyId,
        performedBy: performedBy,
        itemDescription: itemDescription,
        amount: amount,
        itemType: itemType,
        itemId: itemId,
      );
    } catch (e) {
      print('Error sending admin notification: $e');
    }
  }

  // Static method to send notifications to CAs from anywhere
  static Future<void> sendNotificationToCAs({
    required String action,
    required String companyId,
    required String performedBy,
    required String itemDescription,
    required double amount,
    required String itemType,
    String? itemId,
  }) async {
    try {
      final notificationProvider = NotificationProvider();
      final caEmails = await notificationProvider._getCAEmailsForCompany(
        companyId,
      );

      for (final caEmail in caEmails) {
        if (itemType == 'expense') {
          await notificationProvider.notifyExpenseChange(
            action: action,
            companyId: companyId,
            caEmail: caEmail,
            performedBy: performedBy,
            expenseDescription: itemDescription,
            amount: amount,
            expenseId: itemId,
          );
        } else if (itemType == 'income') {
          await notificationProvider.notifyIncomeChange(
            action: action,
            companyId: companyId,
            caEmail: caEmail,
            performedBy: performedBy,
            incomeDescription: itemDescription,
            amount: amount,
            incomeId: itemId,
          );
        }
      }
    } catch (e) {
      print('Error sending CA notifications: $e');
    }
  }

  // Clear notifications (useful for logout)
  void clearNotifications() {
    _notifications.clear();
    _currentCAEmail = null;
    _isLoading = false;
    _error = null;
    notifyListeners();
  }
}
